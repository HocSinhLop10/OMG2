--[[

 _   _    _   _   _____     _       ___     _   _   _   _   ____   
| | | |  | | | | |_   _|   / \     / _ \   | | | | | | | | | __ )  
| |_| |  | | | |   | |    / _ \   | | | |  | |_| | | | | | |  _ \  
|  _  |  | | | |   | |   / ___ \  | |_| |  |  _  | | |_| | | |_) | 
\_| |_/   \___/    \_/  /_/   \_\  \___/   \_| |_/  \___/  |____/

                        Hutao Hub
]]

---------------------------------------------------------------------------------

local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/SaveManager.lua.txt"))()

local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/SLK-gaming/Fluent/refs/heads/main/InterfaceManager.lua.txt"))()

local minimizeUI = Enum.KeyCode.RightAlt

-- üü¢ Create Main UI
local Window = Fluent:CreateWindow({
    Title = "Hutao Hub [Free] | Forsaken",
    SubTitle = "Version 4.0.9",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = false,
    Theme = "Darker",
    MinimizeKey = minimizeUI
})

-- Tabs
local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "rbxassetid://121302760641013"}),
    Farm = Window:AddTab({ Title = "Farm", Icon = "rbxassetid://121302760641013"}),
    Main = Window:AddTab({ Title = "Main", Icon = "rbxassetid://121302760641013" }),
    Player = Window:AddTab({ Title = "Player", Icon = "rbxassetid://121302760641013" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "rbxassetid://121302760641013" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "rbxassetid://121302760641013" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "rbxassetid://121302760641013" }),
}         

-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("‚Ü≥ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/WEGT92yv")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "", -- Optional
                Duration = 3 
            })
        end
    })

-- Tabs.Farm

do
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local Active = false
    local loopRunning = false
    local CurrentTarget = nil
    local lastAttack = 0

    -- üü¢ Danh s√°ch ∆∞u ti√™n
    local PriorityList = {
        ["0206octavio"] = true
    }

    local function GetPriorityTarget()
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            -- ch·ªâ check model survivors
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                if PriorityList[survivor.Name] then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        return survivor
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestSurvivor()
        -- üî¥ Check ∆∞u ti√™n trong Survivors tr∆∞·ªõc
        local priorityTarget = GetPriorityTarget()
        if priorityTarget then
            return priorityTarget
        end

        -- üîµ N·∫øu kh√¥ng c√≥ trong danh s√°ch ∆∞u ti√™n ‚Üí ch·ªçn g·∫ßn nh·∫•t
        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        local closest, minDist = nil, math.huge
        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = survivor
                end
            end
        end
        return closest
    end

    local function KillTarget(target)
        pcall(function()
            if not target then return end
            local localChar = LocalPlayer.Character
            if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

            -- D·ªãch chuy·ªÉn t·ªõi m·ª•c ti√™u
            localChar.HumanoidRootPart.CFrame = target.HumanoidRootPart.CFrame

            -- Ch·ªâ ƒë√°nh n·∫øu ƒë√£ qua 0.5 gi√¢y t·ª´ l·∫ßn ƒë√°nh tr∆∞·ªõc
            if tick() - lastAttack >= 0.5 then
                lastAttack = tick()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local remote = ReplicatedStorage:FindFirstChild("Modules")
                              and ReplicatedStorage.Modules:FindFirstChild("Network")
                              and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                if remote and typeof(remote.FireServer) == "function" then
                    remote:FireServer("UseActorAbility", "Slash")
                    task.wait(0.05)
                    remote:FireServer("UseActorAbility", "Stab")
                    task.wait(0.05)
                    remote:FireServer("UseActorAbility", "Punch")
                end
            end
        end)
    end

    local function StartLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while Active do
                if not CurrentTarget 
                   or not CurrentTarget.Parent 
                   or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
                   or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestSurvivor()
                end
                if CurrentTarget then
                    KillTarget(CurrentTarget)
                end
                task.wait(0.01)
            end
            loopRunning = false
        end)
    end

    Tabs.Farm:AddToggle("AutoKillSurvivors", {
        Title = "Auto Kill Survivors",
        Default = false,
        Callback = function(Value)
            Active = Value
            if Active then
                StartLoop()
            end
        end
    })
end




local Players = game:GetService("Players")
local PFS = game:GetService("PathfindingService")
local VIM = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LP = Players.LocalPlayer
local Spectators = {}
local currentCharacter
local isInGame, busy, isSprinting = false, false, false
local stamina, counter = 100, 0
local Killer, Survivor = false, false

-- Danh s√°ch killer nguy hi·ªÉm
local DangerousKillers = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

-- üü¢ Danh s√°ch survivor ∆∞u ti√™n (ch·ªâ khi l√† model trong Survivors)
local PriorityList = {
    ["0206octavio"] = true
}

-- H√†m l·∫•y survivor ∆∞u ti√™n
local function GetPriorityTarget(survivorsFolder)
    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
        if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
            if PriorityList[survivor.Name] then
                local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    return survivor
                end
            end
        end
    end
    return nil
end

-- H√†m ki·ªÉm tra c√≥ killer nguy hi·ªÉm g·∫ßn generator kh√¥ng
local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

-- H√†m ki·ªÉm tra m·∫∑t ƒë·∫•t
local function safe(pos)
    local rayParams = RaycastParams.new()
    rayParams.FilterDescendantsInstances = {workspace.Map.Ingame.Map}
    rayParams.FilterType = Enum.RaycastFilterType.Include
    local rayResult = workspace:Raycast(pos + Vector3.new(0, 5, 0), Vector3.new(0, -10, 0), rayParams)
    if rayResult then
        local yDiff = math.abs(rayResult.Position.Y - pos.Y)
        return yDiff < 5
    end
    return false
end

-- N√∫t Toggle Fluent UI
Tabs.Farm:AddToggle("AutoExpMoney", {
    Title = "Auto Farm Exp / Money",
    Default = false
})
:OnChanged(function(Value)
    _G.AutoFarm = Value

    -- C·∫≠p nh·∫≠t Spectators / InGame
    task.spawn(function()
        while _G.AutoFarm do
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)
            task.wait(0.5)
        end
    end)

    -- X√°c ƒë·ªãnh m√¨nh l√† Killer hay Survivor
    task.spawn(function()
        while _G.AutoFarm do
            if workspace:FindFirstChild("Players") then
                local killersFolder = workspace.Players:FindFirstChild("Killers")
                local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
                if killersFolder and survivorsFolder then
                    Killer = killersFolder:FindFirstChild(LP.Name) or table.find(killersFolder:GetChildren(), LP.Character)
                    Survivor = survivorsFolder:FindFirstChild(LP.Name) or table.find(survivorsFolder:GetChildren(), LP.Character)
                end
            end
            task.wait(0.5)
        end
    end)

    -- H√†nh ƒë·ªông ch√≠nh
    task.spawn(function()
        task.wait(0.5)
        local killersFolder = workspace.Players:WaitForChild("Killers")
        local survivorsFolder = workspace.Players:WaitForChild("Survivors")

        while _G.AutoFarm do
            if Killer then
                -- ∆Øu ti√™n target
                local target = GetPriorityTarget(survivorsFolder)

                -- N·∫øu kh√¥ng c√≥ th√¨ ch·ªçn survivor b·∫•t k·ª≥
                if not target then
                    for _, survivor in ipairs(survivorsFolder:GetChildren()) do
                        if survivor:IsA("Model")
                        and survivor:FindFirstChild("HumanoidRootPart")
                        and survivor:FindFirstChild("Humanoid")
                        and survivor.Humanoid.Health > 0 then
                            target = survivor
                            break
                        end
                    end
                end

                if target then
                    -- D·ªãch chuy·ªÉn theo target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0 do

                            local character = LP.Character
                            if character and character:FindFirstChild("HumanoidRootPart") and target:FindFirstChild("HumanoidRootPart") then
                                character:PivotTo(target.HumanoidRootPart.CFrame)
                            end
                            task.wait(0.1)
                        end
                    end)

                    -- T·∫•n c√¥ng target
                    task.spawn(function()
                        while _G.AutoFarm
                        and target
                        and target:IsDescendantOf(survivorsFolder)
                        and target:FindFirstChild("Humanoid")
                        and target.Humanoid.Health > 0
                        and target:FindFirstChild("HumanoidRootPart") do

                            for _, key in ipairs({Enum.KeyCode.Q, Enum.KeyCode.E, Enum.KeyCode.R}) do
                                if not _G.AutoFarm then break end
                                VIM:SendMouseButtonEvent(0, 0, 0, true, game, 0)
                                task.wait(0.05)
                                VIM:SendMouseButtonEvent(0, 0, 0, false, game, 0)
                                VIM:SendKeyEvent(true, key, false, game)
                                task.wait(0.05)
                                VIM:SendKeyEvent(false, key, false, game)
                                task.wait(0.1)
                            end
                            task.wait(0.8)
                        end
                    end)
                else
                    task.wait(0.5)
                end

            elseif Survivor then
                if isInGame then
                    -- L·∫•y character
                    for _, surv in ipairs(survivorsFolder:GetChildren()) do
                        if surv:GetAttribute("Username") == LP.Name then
                            currentCharacter = surv
                            break
                        end
                    end

                    -- Check ch·∫øt th√¨ reset
                    task.spawn(function()
                        while _G.AutoFarm do
                            if currentCharacter and currentCharacter:FindFirstChild("Humanoid") and currentCharacter.Humanoid.Health <= 0 then
                                isInGame = false
                                isSprinting = false
                                busy = false
                                break
                            end
                            task.wait(0.5)
                        end
                    end)

                    -- L√†m generator
                    for _, gen in ipairs(workspace.Map.Ingame:WaitForChild("Map"):GetChildren()) do
                        if not _G.AutoFarm then break end
                        if gen.Name == "Generator" and gen:FindFirstChild("Progress") and gen.Progress.Value ~= 100 then

                            -- L·∫•y v·ªã tr√≠ ph√≠a tr∆∞·ªõc generator
                            local genCFrame = gen:GetPivot()
                            local goalPos = (genCFrame * CFrame.new(0, 0, -7)).Position

                            -- Anti-Killer check
                            if isKillerNearGenerator(goalPos, 50) then
                                print("‚ö†Ô∏è B·ªè qua generator v√¨ killer nguy hi·ªÉm ·ªü g·∫ßn!")
                                continue
                            end

                            if currentCharacter and currentCharacter:FindFirstChild("HumanoidRootPart") then
                                currentCharacter:PivotTo(CFrame.new(goalPos + Vector3.new(0, 5, 0))) -- ch·ªânh ƒë·ªô cao khi player teleport
                                task.wait(0.75)

                                local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
                                if prompt then
                                    prompt.HoldDuration = 0
                                    prompt.RequiresLineOfSight = false
                                    prompt.MaxActivationDistance = 99999
                                    task.wait(0.15)

                                    pcall(function()
                                        prompt:InputHoldBegin()
                                        prompt:InputHoldEnd()
                                    end)

                                    busy = true
                                    counter = 0
                                    while _G.AutoFarm and gen.Progress.Value ~= 100 do
                                        pcall(function()
                                            prompt:InputHoldBegin()
                                            prompt:InputHoldEnd()
                                            if _G.AutoGeneral == false then
                                                gen.Remotes.RE:FireServer()
                                            end
                                        end)
                                        task.wait(0.75) -- t·ªëc ƒë·ªô m·ªü generator
                                        counter += 1
                                        if counter >= 10 or not isInGame then break end
                                    end
                                    busy = false
                                    if not isInGame then break end
                                end
                            end
                        end
                    end
                end
            end
            task.wait(0.5)
        end
    end)
end)



    Tabs.Farm:AddSection("‚Ü≥ Generator")

local solveGeneratorCooldown = false
local AutoFinishGen = false

-- H√†m t√¨m generator g·∫ßn nh·∫•t
local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

-- N√∫t Finish generator th·ªß c√¥ng
Tabs.Farm:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("‚è≥ Please wait before trying again!") 
            return
        end
        if AutoFinishGen then
            print("‚ùå Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(1.5, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

-- Toggle Auto Finish Generator
Tabs.Farm:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("‚ö†Ô∏è Please wait cooldown before enabling Auto Finish!") 
            -- t·∫Øt toggle qua Fluent.Options
            Fluent.Options.AutoFinishGen:SetValue(false)
            return
        end

        task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(1.5)
                solveGeneratorCooldown = false
            end
        end)
    else
        solveGeneratorCooldown = false
    end
end)




    Tabs.Farm:AddSection("‚Ü≥ Items")

local Players = game:GetService("Players")
local LP = Players.LocalPlayer

-- H√†m nh·∫∑t item g·∫ßn nh·∫•t
local function pickUpNearest()
    local map = workspace:FindFirstChild("Map") 
                and workspace.Map:FindFirstChild("Ingame") 
                and workspace.Map.Ingame:FindFirstChild("Map")
    if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

    local oldCFrame = LP.Character.HumanoidRootPart.CFrame
    for _, item in ipairs(map:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ItemRoot") 
           and item.ItemRoot:FindFirstChild("ProximityPrompt") then
            LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
            task.wait(0.3)
            fireproximityprompt(item.ItemRoot.ProximityPrompt)
            task.wait(0.4)
            LP.Character.HumanoidRootPart.CFrame = oldCFrame
            break
        end
    end
end

-- Button: Pick Up Item (1 l·∫ßn)
Tabs.Farm:AddButton({
    Title = "Pick Up Item",
    Callback = pickUpNearest
})

-- Toggle: Auto PickUp Item (l·∫∑p)
Tabs.Farm:AddToggle("ItemPick", {
    Title = "Auto PickUp Item",
    Default = false
}):OnChanged(function(Value)
    _G.PickupItem = Value
    if not Value then return end

    task.spawn(function()
        while _G.PickupItem do
            pickUpNearest()
            task.wait(0.2) -- delay gi·ªØa m·ªói l·∫ßn nh·∫∑t
        end
    end)
end)




-- Tabs.Main

Tabs.Main:AddParagraph({
    Title = "How to Use Script :",
    Content = "1: Must adjust the slider to increase or decrease\n2: Must not be min or max because it will not work\n3: Then turn on the buttons to use those functions\n\n|| Like, Share And Subscribe For SLK gaming ||"
})




    Tabs.Main:AddSection("‚Ü≥ Shedletsky")


do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5 -- Kho·∫£ng c√°ch m·∫∑c ƒë·ªãnh
    local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- Toggle
    local SlashToggle = Tabs.Main:AddToggle("SlashToggle", {
        Title = "Auto Slash",
        Default = false
    })

    SlashToggle:OnChanged(function(Value)
        enabled = Value
    end)

    -- Slider cho kho·∫£ng c√°ch
    local DistanceSlider = Tabs.Main:AddSlider("DistanceSlider", {
        Title = "Distance",
        Min = 1,
        Max = 50,
        Default = 5,
        Rounding = 1,
        ValueName = "studs"
    })

    DistanceSlider:OnChanged(function(Value)
        maxDistance = Value
    end)

    -- Helper (ki·ªÉm tra ƒë·ª©ng sau l∆∞ng thay v√¨ tr∆∞·ªõc m·∫∑t)
    local function isBehindTarget(hrp, targetHRP)
        local direction = targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) < -0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local backPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(backPos, kHRP.Position)

                    -- Gi·ªØ v·ªã tr√≠ v√† spam skill trong 0.7s
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 1 then         
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        -- Lu√¥n gi·ªØ ·ªü sau l∆∞ng
                        local back = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(back, kHRP.Position)

                        -- K√≠ch ho·∫°t skill Slash li√™n t·ª•c
                        remote:FireServer("UseActorAbility", "Slash")
                    end)

                    break
                end
            end
        end
    end)
end





do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local healEnabled = false
    local healHPThreshold = 50
    local healDistance = 50
    local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

    -- UI
    local HealToggle = Tabs.Main:AddToggle("HealToggle", {
        Title = "Auto Heal",
        Default = false
    })
    HealToggle:OnChanged(function(v) healEnabled = v end)

    local HealHPSlider = Tabs.Main:AddSlider("HealHPSlider", {
        Title = "Heal HP",
        Min = 1, Max = 100, Default = 50,
        Rounding = 0, ValueName = "HP"
    })
    HealHPSlider:OnChanged(function(v) healHPThreshold = v end)

    local HealDistanceSlider = Tabs.Main:AddSlider("HealDistanceSlider", {
        Title = "Distance",
        Min = 1, Max = 150, Default = 50,
        Rounding = 0, ValueName = "studs"
    })
    HealDistanceSlider:OnChanged(function(v) healDistance = v end)

    -- Helpers -------------------------------------------------------------

    local function getPlayersFolders()
        local pf = workspace:FindFirstChild("Players")
        if not pf then return nil, nil, nil end
        return pf, pf:FindFirstChild("Killers"), pf:FindFirstChild("Survivors")
    end

    -- model n√†y c√≥ ph·∫£i c·ªßa LocalPlayer kh√¥ng?
    local function belongsToMe(m)
        if not (m and m:IsA("Model")) then return false end
        if m:GetAttribute("Username") == lp.Name then return true end
        local UsernameSV = m:FindFirstChild("Username")
        if UsernameSV and typeof(UsernameSV.Value) == "string" and UsernameSV.Value == lp.Name then return true end
        local Owner = m:FindFirstChild("Owner") or m:FindFirstChild("Player")
        if Owner and Owner.Value == lp then return true end
        local uidAttr = m:GetAttribute("UserId")
        if uidAttr and tonumber(uidAttr) == lp.UserId then return true end
        -- ƒë√¥i khi model ƒë·∫∑t ƒë√∫ng t√™n player
        if m.Name == lp.Name then return true end
        return false
    end

    -- t√¨m model Shedletsky c·ªßa CH√çNH B·∫†N ·ªü m·ªçi n∆°i
    local function getMyShedletsky()
        local pf, killersFolder, survivorsFolder = getPlayersFolders()

        local candidates = {}

        local function scan(container)
            if not container then return end
            for _, d in ipairs(container:GetDescendants()) do
                if d:IsA("Model") and d.Name == "Shedletsky" and d:FindFirstChild("Humanoid") and d:FindFirstChild("HumanoidRootPart") then
                    if belongsToMe(d) then table.insert(candidates, d) end
                end
            end
        end

        scan(killersFolder)
        scan(survivorsFolder)
        scan(workspace) -- fallback n·∫øu game ƒë·∫∑t ·ªü root/nh√°nh kh√°c

        if #candidates == 0 then return nil, nil, nil end

        -- n·∫øu c√≥ nhi·ªÅu, ch·ªçn c√°i g·∫ßn lp.Character nh·∫•t (·ªïn ƒë·ªãnh h∆°n)
        local basePos
        if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
            basePos = lp.Character.HumanoidRootPart.Position
        end

        local best, bestDist = candidates[1], math.huge
        if basePos then
            for _, m in ipairs(candidates) do
                local hrp = m:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local d = (hrp.Position - basePos).Magnitude
                    if d < bestDist then best, bestDist = m, d end
                end
            end
        end

        local hum = best:FindFirstChildOfClass("Humanoid")
        local hrp = best:FindFirstChild("HumanoidRootPart")
        return best, hum, hrp
    end

    local function getNearestKillerDist(fromHRP, myModel)
        local _, killersFolder = getPlayersFolders()
        if not (killersFolder and fromHRP) then return math.huge end
        local nearest = math.huge
        for _, k in ipairs(killersFolder:GetChildren()) do
            if k ~= myModel then -- tr√°nh ƒëo t·ªõi ch√≠nh m√¨nh n·∫øu m√¨nh c≈©ng ·ªü Killers
                local khrp = k:FindFirstChild("HumanoidRootPart")
                if khrp then
                    local d = (fromHRP.Position - khrp.Position).Magnitude
                    if d < nearest then nearest = d end
                end
            end
        end
        return nearest
    end

    -- Main loop ----------------------------------------------------------
    RunService.Heartbeat:Connect(function()
        if not healEnabled then return end

        -- CH·ªà ch·∫°y khi b·∫°n l√† Shedletsky
        local myModel, myHumanoid, myHRP = getMyShedletsky()
        if not (myModel and myHumanoid and myHRP) then return end
        if myHumanoid.Health <= 0 then return end

        -- kho·∫£ng c√°ch t·ª´ Shedletsky (b·∫°n) ‚Üí Killers
        local nearestDist = getNearestKillerDist(myHRP, myModel)

        -- Heal khi HP th·∫•p v√† ƒê·ª¶ XA killers (>=)
        if myHumanoid.Health <= healHPThreshold and nearestDist >= healDistance then
            pcall(function()
                remote:FireServer("UseActorAbility", "FriedChicken")
            end)
        end
    end)
end


    Tabs.Main:AddSection("‚Ü≥ Chance")

-- ==================================================
-- üìå H·ª£p nh·∫•t: Aimbot + Auto Coinflip
-- ==================================================

do
-- ‚öôÔ∏è Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

-- ==================================================
-- üéØ AIMBOT STATE
-- ==================================================
local active = false
local predictionMode = "Speed"
local aimMode = "Normal"
local aimDuration = 1.7
local fasterDuration = 1.5
local spinDuration = 0.5
local aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli"}

-- Aimbot runtime
local Humanoid, HRP = nil, nil
local originalWS, originalJP, originalAutoRotate = nil, nil, nil
local aiming = false
local prevFlintVisibleAim = false
local lastTriggerTime = 0

-- ==================================================
-- üí∞ COINFLIP STATE
-- ==================================================
local autoCoinflip = false
local coinflipTargetCharge = 3
local coinflipCooldown = 0.15
local lastCoinflipTime = 0

local RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")

-- ==================================================
-- üîò Fluent UI
-- ==================================================
-- Aimbot UI
Tabs.Main:AddDropdown("AimMode", {
    Title = "Aim Mode",
    Values = {"Normal", "Faster", "Reflex"},
    Default = "Normal",
    Callback = function(val) aimMode = val end
})

Tabs.Main:AddDropdown("PredictionMode", {
    Title = "Prediction Mode",
    Values = {"Speed", "Ping", "front", "No Lag"},
    Default = "Speed",
    Callback = function(val) predictionMode = val end
})

-- ‚úÖ Coinflip Point Dropdown (b√™n d∆∞·ªõi 2 dropdown Aimbot) - hi·ªÉn th·ªã "1 Point/2 Point/3 Point"
Tabs.Main:AddDropdown("CoinflipChargeDropdown", {
    Title = "Select Score",
    Values = {"1 Point", "2 Point", "3 Point"},
    Default = "3 Point",
}):OnChanged(function(val)
    -- t√°ch s·ªë ·ªü ƒë·∫ßu chu·ªói: "3 Point" -> 3
    local num = tonumber(val and val:match("%d+"))
    if num then
        coinflipTargetCharge = num
    end
end)

-- Aimbot Toggle
Tabs.Main:AddToggle("AimbotToggle", {
    Title = "Auto Aim Shoot",
    Default = false,
    Callback = function(state) active = state end
})

-- Coinflip Toggle
Tabs.Main:AddToggle("AutoCoinflipToggle", {
    Title = "Auto Coin Flip",
    Default = false,
}):OnChanged(function(state)
    autoCoinflip = state
end)

-- ==================================================
-- üìå Helpers Aimbot
-- ==================================================
local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
end
if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function getValidTarget()
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, name in ipairs(aimTargets) do
            local target = killersFolder:FindFirstChild(name)
            if target and target:FindFirstChild("HumanoidRootPart") then
                return target.HumanoidRootPart
            end
        end
    end
    return nil
end

local function getPingSeconds()
    local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
    if pingStat then return pingStat:GetValue() / 1000 end
    return 0.1
end

local function isFlintlockVisible()
    if not LocalPlayer.Character then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end
    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end
    return flint.Transparency < 1
end

local movementThreshold = 0.5
local function getPredictedAimPosPing(targetHRP)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity
    if velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (velocity * ping)
end

local function getPredictedAimPosInfrontHRPPing(targetHRP)
    local ping = getPingSeconds()
    local studs = ping * 60
    if targetHRP.Velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
end

-- üìå Helpers Coinflip
local function readCoinflipChargesText()
    local ok, txt = pcall(function()
        local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
        if not mainUI then return nil end
        local abil = mainUI:FindFirstChild("AbilityContainer")
        if not abil then return nil end
        local coin = abil:FindFirstChild("Reroll")
        if not coin then return nil end
        local chargesLabel = coin:FindFirstChild("Charges")
        if not chargesLabel then return nil end
        return tonumber(chargesLabel.Text)
    end)
    if ok then return txt end
    return nil
end

-- ==================================================
-- üî• MAIN LOOP (RenderStepped)
-- ==================================================
RunService.RenderStepped:Connect(function()
    -- ===== AIMBOT =====
    if active and Humanoid and HRP then
        local isVisible = isFlintlockVisible()
        if isVisible and not prevFlintVisibleAim and not aiming then
            lastTriggerTime = tick()
            aiming = true
        end
        prevFlintVisibleAim = isVisible

        if aiming then
            local elapsed = tick() - lastTriggerTime

            if aimMode == "Reflex" then
                if elapsed <= spinDuration then
                    local spinProgress = elapsed / spinDuration
                    local spinAngle = math.rad(360 * spinProgress)
                    HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0)
                elseif elapsed <= spinDuration + 0.7 then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        local aimPos
                        if predictionMode == "Ping" then
                            aimPos = getPredictedAimPosPing(targetHRP)
                        elseif predictionMode == "front" then
                            aimPos = targetHRP.Position + targetHRP.CFrame.LookVector * 4
                        elseif predictionMode == "No Lag" then
                            aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                        else
                            aimPos = targetHRP.Position + targetHRP.Velocity * (4 / 60)
                        end
                        if aimPos then
                            local direction = (aimPos - HRP.Position).Unit
                            local yRot = math.atan2(-direction.X, -direction.Z)
                            HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                        end
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
                            originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end

            elseif aimMode == "Normal" or aimMode == "Faster" then
                local duration = (aimMode == "Faster") and fasterDuration or aimDuration
                if elapsed <= duration then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        local aimPos
                        if predictionMode == "Ping" then
                            aimPos = getPredictedAimPosPing(targetHRP)
                        elseif predictionMode == "front" then
                            aimPos = targetHRP.Position + targetHRP.CFrame.LookVector * 4
                        elseif predictionMode == "No Lag" then
                            aimPos = getPredictedAimPosInfrontHRPPing(targetHRP)
                        else
                            aimPos = targetHRP.Position + targetHRP.Velocity * (4 / 60)
                        end
                        if aimPos then
                            local direction = (aimPos - HRP.Position).Unit
                            local yRot = math.atan2(-direction.X, -direction.Z)
                            HRP.CFrame = CFrame.new(HRP.Position) * CFrame.Angles(0, yRot, 0)
                        end
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
                            originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end
            end
        end
    end

    -- ===== AUTO COINFLIP =====
    if autoCoinflip then
        local charges = readCoinflipChargesText()
        if charges and charges < coinflipTargetCharge then
            local now = tick()
            if now - lastCoinflipTime >= coinflipCooldown then
                lastCoinflipTime = now
                pcall(function()
                    RemoteEvent:FireServer(table.unpack({
                        [1] = "UseActorAbility",
                        [2] = "CoinFlip",
                    }))
                end)
            end
        end
    end
end)
end



    Tabs.Main:AddSection("‚Ü≥ Two Time")

do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local lp = Players.LocalPlayer

    -- Vars
    local enabled = false
    local cooldown = false
    local lastTarget = nil
    local maxDistance = 5 -- Kho·∫£ng c√°ch m·∫∑c ƒë·ªãnh
    local remote = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
    local killerNames = { "Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli" }
    local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")

    -- Toggle
    local BackstabToggle = Tabs.Main:AddToggle("BackstabToggle", {
        Title = "Auto Backstab",
        Default = false
    })

    BackstabToggle:OnChanged(function(Value)
        enabled = Value
    end)

    -- Slider cho kho·∫£ng c√°ch
    local DistanceSlider = Tabs.Main:AddSlider("DistanceSlider", {
        Title = "Distance",
        Min = 1,
        Max = 50,
        Default = 5,
        Rounding = 1,
        ValueName = "studs"
    })

    DistanceSlider:OnChanged(function(Value)
        maxDistance = Value
    end)

    -- Helper
    local function isBehindTarget(hrp, targetHRP)
        local direction = -targetHRP.CFrame.LookVector
        local toPlayer = (hrp.Position - targetHRP.Position)
        local distance = toPlayer.Magnitude
        local isBehind = toPlayer:Dot(direction) > 0.5
        return distance <= maxDistance and isBehind
    end

    -- Main loop
    RunService.Heartbeat:Connect(function()
        if not enabled or cooldown then return end

        local char = lp.Character
        if not (char and char:FindFirstChild("HumanoidRootPart")) then return end
        local hrp = char.HumanoidRootPart

        for _, name in ipairs(killerNames) do
            local killer = killersFolder:FindFirstChild(name)
            if killer and killer:FindFirstChild("HumanoidRootPart") then
                local kHRP = killer.HumanoidRootPart

                if isBehindTarget(hrp, kHRP) and killer ~= lastTarget then
                    cooldown = true
                    lastTarget = killer

                    -- Teleport ra sau l∆∞ng
                    local behindPos = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                    hrp.CFrame = CFrame.new(behindPos, behindPos + kHRP.CFrame.LookVector)

                    -- Gi·ªØ v·ªã tr√≠ v√† spam skill trong 0.7s
                    local start = tick()
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not (char and char.Parent and kHRP and kHRP.Parent) then
                            if connection then connection:Disconnect() end
                            return
                        end
                        if tick() - start >= 0.7 then
                            if connection then connection:Disconnect() end
                            task.delay(2, function()
                                cooldown = false
                                lastTarget = nil
                            end)
                            return
                        end

                        -- Lu√¥n gi·ªØ sau l∆∞ng
                        local behind = kHRP.Position - (kHRP.CFrame.LookVector * 2)
                        hrp.CFrame = CFrame.new(behind, behind + kHRP.CFrame.LookVector)

                        -- K√≠ch ho·∫°t k·ªπ nƒÉng li√™n t·ª•c
                        remote:FireServer("UseActorAbility", "Dagger")
                    end)

                    break
                end
            end
        end
    end)
end



    Tabs.Main:AddSection("‚Ü≥ 007n7")

do
    -- Invisible upon Cloning (sandboxed)
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local running = false
    local animTrack

    local function getHumanoid()
        local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        return char:FindFirstChildOfClass("Humanoid"), char
    end

    local function getAnimator(humanoid)
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then
            animator = Instance.new("Animator")
            animator.Parent = humanoid
        end
        return animator
    end

    local function playInvisibleAnim(humanoid)
        local animator = getAnimator(humanoid)
        if not animTrack or not animTrack.IsPlaying then
            local animation = Instance.new("Animation")
            animation.AnimationId = "rbxassetid://75804462760596"
            animTrack = animator:LoadAnimation(animation)
            animTrack.Looped = true
            animTrack:Play()
            animTrack:AdjustSpeed(0)
        end
    end

    local function stopInvisibleAnim()
        if animTrack and animTrack.IsPlaying then
            animTrack:Stop()
            animTrack = nil
        end
    end

    local function handleToggle(enabled)
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if enabled then
            running = true
            task.spawn(function()
                while running do
                    humanoid, char = getHumanoid()
                    if not humanoid or not char then break end

                    local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
                    local root = char:FindFirstChild("HumanoidRootPart")

                    if torso and torso.Transparency ~= 0 then
                        playInvisibleAnim(humanoid)
                        if root then root.Transparency = 0.4 end
                    else
                        stopInvisibleAnim()
                        if root then root.Transparency = 1 end
                    end

                    task.wait(0.5)
                end
            end)
        else
            running = false
            stopInvisibleAnim()
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Transparency = 1
            end
        end
    end

    -- === Toggle g·ªëc: Invisible if cloned ===
    Tabs.Main:AddToggle("InvisibleClone", {
        Title = "Invisible if cloned",
        Default = false
    }):OnChanged(function(val)
        handleToggle(val)
    end)

    -- === Toggle m·ªõi: Invisible lu√¥n khi b·∫≠t ===
    Tabs.Main:AddToggle("InstantInvisible", {
        Title = "Invisible Immediately",
        Default = false
    }):OnChanged(function(val)
        -- Khi b·∫≠t, t√†ng h√¨nh ngay l·∫≠p t·ª©c
        local humanoid, char = getHumanoid()
        if not humanoid or not char then return end

        if val then
            playInvisibleAnim(humanoid)
            local root = char:FindFirstChild("HumanoidRootPart")
            if root then root.Transparency = 0.4 end
        else
            stopInvisibleAnim()
            local humanoid, char = getHumanoid()
            if char and char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Transparency = 1
            end
        end
    end)
end


    Tabs.Main:AddSection("‚Ü≥ Guest1337")


do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer

    -- ‚úÖ Animation IDs c·∫ßn ch·∫∑n (merge t·ª´ list m·ªõi + c≈©, lo·∫°i b·ªè tr√πng)
    local animationIds = {
        ["126830014841198"] = true,
        ["126355327951215"] = true,
        ["121086746534252"] = true,
        ["18885909645"]     = true,
        ["98456918873918"]  = true,
        ["105458270463374"] = true,
        ["83829782357897"]  = true,
        ["125403313786645"] = true,
        ["118298475669935"] = true,
        ["82113744478546"]  = true,
        ["70371667919898"]  = true,
        ["99135633258223"]  = true,
        ["97167027849946"]  = true,
        ["109230267448394"] = true,
        ["139835501033932"] = true,
        ["126896426760253"] = true,
        ["109667959938617"] = true,
        ["126681776859538"] = true,
        ["129976080405072"] = true,
        ["121293883585738"] = true,
        ["81639435858902"]  = true,
        ["137314737492715"] = true,
        ["92173139187970"]  = true,
    }

    local toggleOn = false
    local strictRangeOn = false
    local detectionRange = 18

    -- ‚ö° Cache BlockButton & connections
    local blockButton, connections = nil, {}

    local function initBlockButton()
        local gui = localPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        blockButton = container and container:FindFirstChild("Block")

        if blockButton and blockButton:IsA("ImageButton") then
            connections = getconnections(blockButton.MouseButton1Click)
        end
    end

    initBlockButton()
    localPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initBlockButton()
    end)

    -- ‚úÖ H√†m block nhanh
    local function clickBlockButton()
        if not blockButton or not blockButton.Visible then return end
        for _, conn in ipairs(connections) do
            pcall(function() conn:Fire() end)
        end
        pcall(function() blockButton:Activate() end)
    end

    -- üìù Persistent flags
    local function getBoolFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("BoolValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local function getNumberFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("NumberValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local toggleFlag = getBoolFlag("AutoBlockToggle", false)
    local strictFlag = getBoolFlag("AutoBlockStrictRange", false)
    local rangeFlag = getNumberFlag("AutoBlockRange", 18)

    toggleOn = toggleFlag.Value
    strictRangeOn = strictFlag.Value
    detectionRange = rangeFlag.Value

    -- üïπ GUI
    Tabs.Main:AddToggle("AutoBlockV2", {
        Title = "Auto Block",
        Default = toggleOn,
    }):OnChanged(function(state)
        toggleOn = state
        toggleFlag.Value = state
    end)

    Tabs.Main:AddToggle("StrictRangeCheck", {
        Title = "Auto Check",
        Default = strictRangeOn,
    }):OnChanged(function(state)
        strictRangeOn = state
        strictFlag.Value = state
    end)

    Tabs.Main:AddSlider("RangeCheckSlider", {
        Title = "Range Check",
        Min = 1,
        Max = 100,
        Default = detectionRange,
        Rounding = 1,
    }):OnChanged(function(value)
        detectionRange = value
        rangeFlag.Value = value
    end)

    -- ‚ö° Qu·∫£n l√Ω anim ƒëang ch·∫°y
    local activeTracks = {}

    local function hookPlayer(player)
        local char = player.Character
        if not char then return end
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        humanoid.AnimationPlayed:Connect(function(track)
            if not toggleOn then return end
            local anim = track.Animation
            if not anim or not anim.AnimationId then return end

            local id = string.match(anim.AnimationId, "%d+")
            if id and animationIds[id] then
                -- ki·ªÉm tra range n·∫øu b·∫≠t strict
                if strictRangeOn then
                    local myChar = localPlayer.Character
                    local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
                    local theirRoot = char:FindFirstChild("HumanoidRootPart")
                    if myRoot and theirRoot then
                        local dist = (theirRoot.Position - myRoot.Position).Magnitude
                        if dist > detectionRange then return end
                    end
                end

                activeTracks[track] = true
                track.Stopped:Connect(function()
                    activeTracks[track] = nil
                end)
            end
        end)
    end

    -- hook player hi·ªán c√≥ + player m·ªõi
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= localPlayer then
            p.CharacterAdded:Connect(function()
                task.wait(1)
                hookPlayer(p)
            end)
            if p.Character then
                hookPlayer(p)
            end
        end
    end

    Players.PlayerAdded:Connect(function(p)
        if p ~= localPlayer then
            p.CharacterAdded:Connect(function()
                task.wait(1)
                hookPlayer(p)
            end)
        end
    end)

    -- ‚ö° Loop spam block khi c√≥ anim
    task.spawn(function()
        while true do
            if toggleOn and next(activeTracks) then
                clickBlockButton()
            end
            task.wait(0.005)
        end
    end)
end






do
    -- Auto Punch settings
    local autoPunchOn, aimPunch, flingPunchOn, customPunchEnabled = false, false, false, false
    local hiddenfling = false
    local flingPower = 10000
    local predictionValue = 4
    local customPunchAnimId = ""
    local Humanoid
    local lastPunchTime = 0
    local punchAnimIds = { "87259391926321" }
    local LP = game:GetService("Players").LocalPlayer
    local RunService = game:GetService("RunService")
    local PlayerGui = LP:WaitForChild("PlayerGui")

    -- Function: play custom punch anim
    local function playCustomPunch(animId)
        if not Humanoid then return end
        if not animId or animId == "" then return end
        local now = tick()
        if now - lastPunchTime < 1 then return end

        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            local animNum = tostring(track.Animation.AnimationId):match("%d+")
            if table.find(punchAnimIds, animNum) then
                track:Stop()
            end
        end

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animId
        local track = Humanoid:LoadAnimation(anim)
        track:Play()
        lastPunchTime = now
    end

    -- Hidden fling coroutine
    coroutine.wrap(function()
        local hrp, c, vel, movel = nil, nil, nil, 0.1
        while true do
            RunService.Heartbeat:Wait()
            if hiddenfling then
                while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = LP.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end
                if hiddenfling then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                    RunService.Stepped:Wait()
                    hrp.Velocity = vel + Vector3.new(0, movel, 0)
                    movel = movel * -1
                end
            end
        end
    end)()

    -- Auto Punch loop
    RunService.RenderStepped:Connect(function()
        local myChar = LP.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        Humanoid = myChar:FindFirstChildOfClass("Humanoid")

        if autoPunchOn then
            local gui = PlayerGui:FindFirstChild("MainUI")
            local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
            local charges = punchBtn and punchBtn:FindFirstChild("Charges")

            if charges and charges.Text == "1" then
                local killerNames = {"c00lkidd", "Slasher", "JohnDoe", "1x1x1x1", "Noli"}
                for _, name in ipairs(killerNames) do
                    local killer = workspace:FindFirstChild("Players")
                        and workspace.Players:FindFirstChild("Killers")
                        and workspace.Players.Killers:FindFirstChild(name)

                    if killer and killer:FindFirstChild("HumanoidRootPart") then
                        local root = killer.HumanoidRootPart
                        if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then
                            
                            -- Aim Punch
                            if aimPunch then
                                local humanoid = myChar:FindFirstChild("Humanoid")
                                if humanoid then humanoid.AutoRotate = false end
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 2 do
                                        if myRoot and root and root.Parent then
                                            local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
                                            myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                                        end
                                        task.wait()
                                    end
                                    if humanoid then humanoid.AutoRotate = true end
                                end)
                            end

                            -- Click punch button
                            for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
                                pcall(function() conn:Fire() end)
                            end

                            -- Fling Punch
                            if flingPunchOn then
                                hiddenfling = true
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 1 do
                                        if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and root and root.Parent then
                                            local frontPos = root.Position + (root.CFrame.LookVector * 2)
                                            LP.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, root.Position)
                                        end
                                        task.wait()
                                    end
                                    hiddenfling = false
                                end)
                            end

                            -- Custom anim
                            if customPunchEnabled and customPunchAnimId ~= "" then
                                playCustomPunch(customPunchAnimId)
                            end

                            break -- ch·ªâ ƒë√°nh 1 killer m·ªói v√≤ng
                        end
                    end
                end
            end
        end
    end)

    -- === N√∫t cho Tabs.Main (th√™m v√†o GUI c√≥ s·∫µn) ===
    Tabs.Main:AddToggle("AutoPunch", { Title = "Auto Punch", Default = false })
        :OnChanged(function(val) autoPunchOn = val end)

    Tabs.Main:AddToggle("AimPunch", { Title = "Punch Aimbot", Default = false })
        :OnChanged(function(val) aimPunch = val end)

    Tabs.Main:AddToggle("FlingPunch", { Title = "Fling Punch", Default = false })
        :OnChanged(function(val) flingPunchOn = val end)

    Tabs.Main:AddSlider("Prediction", {
        Title = "Aim Prediction",
        Min = 0, Max = 10, Default = 4, Rounding = 1,
    }):OnChanged(function(val) predictionValue = val end)

    Tabs.Main:AddSlider("FlingPower", {
        Title = "Fling Power",
        Min = 5000, Max = 500000, Default = 10000, Rounding = 0,
    }):OnChanged(function(val) flingPower = val end)

    Tabs.Main:AddInput("CustomAnim", {
        Title = "Custom Punch",
        Default = "",
        Placeholder = "Enter Animation ID"
    }):OnChanged(function(txt) customPunchAnimId = txt end)

    Tabs.Main:AddToggle("EnableCustomAnim", { Title = "Enable Custom Animation", Default = false })
        :OnChanged(function(val) customPunchEnabled = val end)
end

    Tabs.Main:AddSection("‚Ü≥ Noli")

do
    -- noli void rush control (sandboxed)
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer

    local voidrushcontrol = false
    local DEFAULT_SPEED = 16
    local DASH_SPEED = 60
    local isOverrideActive = false
    local connection
    local Humanoid, RootPart

    -- Setup nh√¢n v·∫≠t
    local function setupCharacter(character)
        Humanoid = character:WaitForChild("Humanoid")
        RootPart = character:WaitForChild("HumanoidRootPart")
    end

    if LocalPlayer.Character then
        setupCharacter(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(setupCharacter)

    -- B·∫Øt ƒë·∫ßu override void rush
    local function startOverride()
        if isOverrideActive or not Humanoid or not RootPart then return end
        isOverrideActive = true

        connection = RunService.RenderStepped:Connect(function()
            if not Humanoid or not RootPart or Humanoid.Health <= 0 then return end

            Humanoid.WalkSpeed = DASH_SPEED
            Humanoid.AutoRotate = false

            local direction = RootPart.CFrame.LookVector
            local horizontal = Vector3.new(direction.X, 0, direction.Z)
            if horizontal.Magnitude > 0 then
                Humanoid:Move(horizontal.Unit, true)
            end
        end)
    end

    -- D·ª´ng override void rush
    local function stopOverride()
        if not isOverrideActive then return end
        isOverrideActive = false

        if Humanoid then
            Humanoid.WalkSpeed = DEFAULT_SPEED
            Humanoid.AutoRotate = true
            Humanoid:Move(Vector3.zero, true)
        end

        if connection then
            connection:Disconnect()
            connection = nil
        end
    end

    -- Main loop: detect void rush state
    RunService.RenderStepped:Connect(function()
        if not voidrushcontrol or not Humanoid then return end

        local char = Humanoid.Parent
        local state = char and char:GetAttribute("VoidRushState")

        if state == "Dashing" then
            startOverride()
        else
            stopOverride()
        end
    end)

    -- === Th√™m toggle v√†o GUI ===
    Tabs.Main:AddToggle("VoidRushControl", {
        Title = "Void Rush Aimbot",
        Default = false
    }):OnChanged(function(val)
        voidrushcontrol = val
    end)
end




-- Tabs.Player

-- ======= D·ªäCH V·ª§ =======
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ======= WHITELIST =======
local AllowedPlayers = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
    ["Dusekkar"] = true,
}

local AllowedKillers = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true,
}

-- ======= BI·∫æN TR·∫†NG TH√ÅI =======
local AimlockPlayerEnabled = false
local AimlockKillerEnabled = false
local CurrentTarget = nil

-- ======= H√ÄM H·ªñ TR·ª¢ =======
local function IsAllowed(model, list)
    return list[model.Name] == true
end

local function GetModelFromPlayer(plr, list)
    if not plr.Character then return nil end
    if IsAllowed(plr.Character, list) and plr.Character:FindFirstChildWhichIsA("Humanoid") then
        return plr.Character
    end
    for _, model in ipairs(workspace:GetChildren()) do
        if model:IsA("Model") and model:FindFirstChildWhichIsA("Humanoid") then
            if model:FindFirstChild("Owner") and model.Owner.Value == plr then
                if IsAllowed(model, list) then
                    return model
                end
            end
        end
    end
    return nil
end

local function GetClosestTarget(list)
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return nil end
    local closest, dist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local model = GetModelFromPlayer(plr, list)
            if model and model.PrimaryPart then
                local humanoid = model:FindFirstChildWhichIsA("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local distance = (model.PrimaryPart.Position - myRoot.Position).Magnitude
                    if distance < dist then
                        dist = distance
                        closest = model
                    end
                end
            end
        end
    end
    return closest
end

-- ======= KI·ªÇM TRA TARGET HI·ªÜN T·∫†I =======
local function ValidateTarget(target)
    if not target then return false end
    local humanoid = target:FindFirstChildWhichIsA("Humanoid")
    return humanoid and humanoid.Health > 0 and target.PrimaryPart ~= nil
end

-- ======= AIMLOCK LOOP =======
RunService.RenderStepped:Connect(function()
    if AimlockPlayerEnabled then
        if not ValidateTarget(CurrentTarget) then
            CurrentTarget = GetClosestTarget(AllowedPlayers)
        end
        if ValidateTarget(CurrentTarget) then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, CurrentTarget.PrimaryPart.Position)
        end
    elseif AimlockKillerEnabled then
        if not ValidateTarget(CurrentTarget) then
            CurrentTarget = GetClosestTarget(AllowedKillers)
        end
        if ValidateTarget(CurrentTarget) then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, CurrentTarget.PrimaryPart.Position)
        end
    else
        -- n·∫øu t·∫Øt aimlock th√¨ reset target
        CurrentTarget = nil
    end
end)

-- ======= FLUENT TOGGLES =======
Tabs.Player:AddToggle("ForsakenAimlock", {
    Title = "Aimlock Player",
    Default = false
}):OnChanged(function(v)
    AimlockPlayerEnabled = v
    if v then 
        AimlockKillerEnabled = false
        CurrentTarget = nil -- reset ƒë·ªÉ ch·ªçn l·∫°i khi b·∫≠t
    end
end)

Tabs.Player:AddToggle("ForsakenAimlock1", {
    Title = "Aimlock Killer",
    Default = false
}):OnChanged(function(v)
    AimlockKillerEnabled = v
    if v then 
        AimlockPlayerEnabled = false
        CurrentTarget = nil -- reset ƒë·ªÉ ch·ªçn l·∫°i khi b·∫≠t
    end
end)




    Tabs.Player:AddSection("‚Ü≥ Cheats")
local ActiveNoStun = false
local noStunLoop

Tabs.Player:AddToggle("NoStunToggle", {
    Title = "No Stun",
    Default = false,
}):OnChanged(function(value)
    ActiveNoStun = value

    if value then
        -- N·∫øu c√≥ loop c≈© th√¨ d·ª´ng
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        -- T·∫°o loop m·ªõi li√™n t·ª•c ƒë·∫£m b·∫£o HumanoidRootPart kh√¥ng b·ªã anchore
        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1) -- Kh√¥ng c·∫ßn qu√° nhanh, tr√°nh lag
            end
        end)
    else
        -- T·∫Øt loop khi toggle off
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)







local InfStaminaEnabled = false  
local staminaLoop  
local StaminaModule  
  
-- Th·ª≠ l·∫•y module an to√†n  
pcall(function()  
    local ReplicatedStorage = game:GetService("ReplicatedStorage")  
    local path = ReplicatedStorage:FindFirstChild("Systems")  
        and ReplicatedStorage.Systems:FindFirstChild("Character")  
        and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
        and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  
  
    if path then  
        StaminaModule = require(path)  
    end  
end)  
  
-- H√†m h·ªìi stamina an to√†n  
local function restoreStamina()  
    if not StaminaModule then return end  

    local maxStamina = StaminaModule.MaxStamina or 100  
    if StaminaModule.Stamina then  
        -- N·∫øu module c√≥ h√†m "SetStamina" th√¨ d√πng  
        if typeof(StaminaModule.SetStamina) == "function" then  
            StaminaModule:SetStamina(maxStamina)  

        -- N·∫øu c√≥ h√†m "UpdateStamina" th√¨ d√πng  
        elseif typeof(StaminaModule.UpdateStamina) == "function" then  
            StaminaModule:UpdateStamina(maxStamina)  

        -- N·∫øu kh√¥ng c√≥ th√¨ set tr·ª±c ti·∫øp  
        else  
            StaminaModule.Stamina = maxStamina  
        end  
    end  
end  
  
-- Ch·ªâ t·∫°o toggle n·∫øu module t·ªìn t·∫°i  
if StaminaModule then  
    Tabs.Player:AddToggle("InfStamina", {  
        Title = "Infinite Stamina",  
        Default = false  
    }):OnChanged(function(value)  
        -- lu√¥n b·ªçc trong pcall ƒë·ªÉ Fluent kh√¥ng b√°o "Callback error"  
        local ok = pcall(function()  
            InfStaminaEnabled = value  
            if StaminaModule.StaminaLossDisabled ~= nil then  
                StaminaModule.StaminaLossDisabled = value  
            end  
  
            if value then  
                restoreStamina()  
                if not staminaLoop then  
                    staminaLoop = task.spawn(function()  
                        while InfStaminaEnabled do  
                            task.wait(0.01)  
                            restoreStamina()  
                        end  
                        staminaLoop = nil  
                    end)  
                end  
            end  
        end)  
    end)  
else  
    warn("[InfStamina] Sprinting module not found, toggle disabled.")  
end




    Tabs.Player:AddSection("‚Ü≥ Hitbox")


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Danh s√°ch model c·∫ßn tƒÉng hitbox
local targetModels = {
    ["Noob"] = true,
    ["Guest1337"] = true,
    ["Elliot"] = true,
    ["Shedletsky"] = true,
    ["TwoTime"] = true,
    ["007n7"] = true,
    ["Chance"] = true,
    ["Builderman"] = true,
    ["Taph"] = true,
    ["Dusekkar"] = true,
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Quest666"] = true
}

local HitboxEnabled = false
local HitboxScale = 8 -- m·∫∑c ƒë·ªãnh
local originalParts = {} -- l∆∞u thu·ªôc t√≠nh g·ªëc theo part

local function saveOriginal(part)
    originalParts[part] = {
        Size = part.Size,
        Transparency = part.Transparency,
        Color = part.Color,
        Material = part.Material,
        CanCollide = part.CanCollide,
    }
end

-- H√†m √°p d·ª•ng hitbox (square tr√™n XZ v√† tƒÉng chi·ªÅu cao Y theo HitboxScale)
local function applyHitboxToCharacter(char, owner)
    if not HitboxEnabled then return end
    if not char or not char.Parent then return end
    if not targetModels[char.Name] then return end
    if owner == LocalPlayer then return end -- Kh√¥ng √°p d·ª•ng cho b·∫£n th√¢n

    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") then
        if not originalParts[part] then
            saveOriginal(part)
        end

        local orig = originalParts[part]
        -- D√πng max(orig.X, orig.Z) ƒë·ªÉ ƒë∆∞·ª£c h√¨nh vu√¥ng tr√™n m·∫∑t ƒë·∫•t
        local base = math.max(orig.Size.X, orig.Size.Z)
        -- T·∫°o k√≠ch th∆∞·ªõc m·ªõi: X = Z = base * scale, Y = origY * scale (tƒÉng cao)
        local newSize = Vector3.new(base * HitboxScale, orig.Size.Y * HitboxScale, base * HitboxScale)

        -- D·ªãch l√™n n·ª≠a ph·∫ßn ch√™nh l·ªách chi·ªÅu cao ƒë·ªÉ gi·ªØ ch√¢n ·ªü v·ªã tr√≠ t∆∞∆°ng ƒë·ªëi
        local deltaY = (newSize.Y - orig.Size.Y) / 2
        -- Thay ƒë·ªïi size tr∆∞·ªõc r·ªìi di chuy·ªÉn l√™n xu·ªëng
        part.Size = newSize
        part.CFrame = part.CFrame + part.CFrame.UpVector * deltaY

        -- Thay ƒë·ªïi hi·ªÉn th·ªã
        part.Transparency = 0.8
        part.Color = Color3.fromRGB(255, 0, 0)
        part.Material = Enum.Material.Neon
        part.CanCollide = false
    end
end

-- H√†m reset hitbox (ph·ª•c h·ªìi ƒë√∫ng thu·ªôc t√≠nh g·ªëc v√† v·ªã tr√≠)
local function resetHitbox(char)
    if not char or not char.Parent then return end
    local part = char:FindFirstChild("HumanoidRootPart")
    if part and part:IsA("BasePart") and originalParts[part] then
        local orig = originalParts[part]

        -- D·ªãch xu·ªëng b·∫±ng n·ª≠a ph·∫ßn ch√™nh l·ªách hi·ªán t·∫°i -> g√°n size g·ªëc
        local deltaY = (part.Size.Y - orig.Size.Y) / 2
        part.CFrame = part.CFrame - part.CFrame.UpVector * deltaY

        part.Size = orig.Size
        part.Transparency = orig.Transparency
        part.Color = orig.Color
        part.Material = orig.Material
        part.CanCollide = orig.CanCollide

        originalParts[part] = nil
    end
end

-- Slider ch·ªânh scale
Tabs.Player:AddSlider("HitboxScale", {
    Title = "Hitbox Scale",
    Default = 8,
    Min = 1,
    Max = 100,
    Rounding = 1
}):OnChanged(function(value)
    HitboxScale = value
    if HitboxEnabled then
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and plr.Character then
                applyHitboxToCharacter(plr.Character, plr)
            end
        end
    end
end)

-- Toggle b·∫≠t/t·∫Øt (n·∫±m d∆∞·ªõi slider)
Tabs.Player:AddToggle("HitboxToggle", {
    Title = "Hitbox Survivors",
    Default = false
}):OnChanged(function(state)
    HitboxEnabled = state

    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            if state then
                applyHitboxToCharacter(player.Character, player)
            else
                resetHitbox(player.Character)
            end
        end
    end
end)

-- Theo d√µi player m·ªõi v√†o v√† respawn / r·ªùi
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        if HitboxEnabled then
            applyHitboxToCharacter(char, plr)
        end
    end)
    plr.CharacterRemoving:Connect(function(char)
        resetHitbox(char)
    end)
end)

Players.PlayerRemoving:Connect(function(plr)
    if plr.Character then
        resetHitbox(plr.Character)
    end
end)

-- √Åp d·ª•ng cho player hi·ªán t·∫°i
for _, plr in ipairs(Players:GetPlayers()) do
    plr.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        if HitboxEnabled then
            applyHitboxToCharacter(char, plr)
        end
    end)
    plr.CharacterRemoving:Connect(function(char)
        resetHitbox(char)
    end)
    if plr.Character then
        if HitboxEnabled then
            applyHitboxToCharacter(plr.Character, plr)
        end
    end
end




    Tabs.Player:AddSection("‚Ü≥ Walk Speed")


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local ValueSpeed = 16
local ActiveSpeedBoost = false
local speedLoop

local function setSpeed(speed)
    local character = LocalPlayer.Character
    if not character then return end
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.WalkSpeed = speed
        humanoid:SetAttribute("BaseSpeed", speed)
    end
end

-- Khi respawn √°p d·ª•ng l·∫°i t·ªëc ƒë·ªô n·∫øu b·∫≠t
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Slider ch·ªânh t·ªëc ƒë·ªô
Tabs.Player:AddSlider("PlayerSpeedSlider", {
    Title = "Set Speed",
    Min = 0,
    Max = 40,
    Default = ValueSpeed,
    Rounding = 1,
}):OnChanged(function(value)
    ValueSpeed = value
    if ActiveSpeedBoost then
        setSpeed(ValueSpeed)
    end
end)

-- Toggle b·∫≠t/t·∫Øt t·ªëc ƒë·ªô v√† loop tƒÉng t·ªëc li√™n t·ª•c
Tabs.Player:AddToggle("PlayerSpeedToggle", {
    Title = "Walk Speed",
    Default = false,
}):OnChanged(function(value)
    ActiveSpeedBoost = value
    if value then
        setSpeed(ValueSpeed)
        -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p li√™n t·ª•c set t·ªëc ƒë·ªô m·ªói 0.5 gi√¢y
        speedLoop = task.spawn(function()
            while ActiveSpeedBoost do
                setSpeed(ValueSpeed)
                task.wait(0.5)
            end
        end)
    else
        -- T·∫Øt v√≤ng l·∫∑p v√† reset t·ªëc ƒë·ªô v·ªÅ m·∫∑c ƒë·ªãnh 16
        if speedLoop then
            speedLoop = nil
        end
        setSpeed(16)
    end
end)



    Tabs.Player:AddSection("‚Ü≥ Teleport Speed")


-- === Teleport Speed Setup ===
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HRP = Character:WaitForChild("HumanoidRootPart")

local defaultSpeed = 50
local maxSpeed = 300
local currentSpeed = defaultSpeed
local teleportSpeedEnabled = false

-- C·∫≠p nh·∫≠t l·∫°i khi respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    Humanoid = Character:WaitForChild("Humanoid")
    HRP = Character:WaitForChild("HumanoidRootPart")
end)

-- Loop ƒë·ªÉ d·ªãch chuy·ªÉn (teleport speed)
RunService.Heartbeat:Connect(function(dt)
    if teleportSpeedEnabled and Humanoid and HRP then
        if Humanoid.MoveDirection.Magnitude > 0 then
            local moveDir = Humanoid.MoveDirection.Unit
            HRP.CFrame = HRP.CFrame + (moveDir * (currentSpeed * dt))
        end
    end
end)

-- === GUI Bindings ===
-- Slider Teleport Speed
Tabs.Player:AddSlider("TeleportSpeedSlider", {
    Title = "Set Speed",
    Min = 1,
    Max = maxSpeed,
    Default = defaultSpeed,
    Rounding = 1,
}):OnChanged(function(value)
    currentSpeed = value
end)

-- Toggle b·∫≠t/t·∫Øt Teleport Speed
Tabs.Player:AddToggle("TeleportSpeedToggle", {
    Title = "Teleport Speed",
    Default = false,
}):OnChanged(function(enabled)
    teleportSpeedEnabled = enabled
end)

     

-- Tabs.Visual

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- üìå Danh s√°ch model Clone
local allowedModelsClone = {
    ["1x1x1x1Zombie"] = true,
    ["PizzaDeliveryRig"] = true,
    ["Mafia1"] = true,
    ["Mafia2"] = true,
}

-- Internal containers
local drawingsClone = {}
local espConnectionClone
local addedConnClone, removedConnClone

-- T·∫°o/kh√¥i ph·ª•c ESP + Highlight (t·ª± h·ªìi ph·ª•c n·∫øu m·∫•t)
local function createOrRepairESP(model, drawings, color)
    if not model then return end

    local data = drawings[model]
    if not data then
        -- Ch·ªâ kh·ªüi t·∫°o khi c√≥ HRP
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model

        drawings[model] = { text = text, highlight = highlight }
        return
    end

    -- H·ªìi ph·ª•c n·∫øu m·∫•t th√†nh ph·∫ßn
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if (not data.highlight) or (not data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model
        data.highlight = highlight
    else
        -- ƒê·∫£m b·∫£o lu√¥n b√°m ƒë√∫ng model
        data.highlight.Adornee = model
        data.highlight.Enabled = true
        data.highlight.FillColor = color
        data.highlight.OutlineColor = color
    end
end

-- Xo√° ESP
local function removeESP(model, drawings)
    local data = drawings[model]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[model] = nil
end

-- Qu√©t workspace v√† t·∫°o ESP
local function scanWorkspaceForAllowed(allowedList, drawings, color)
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedList[obj.Name] and obj:FindFirstChild("HumanoidRootPart") then
            createOrRepairESP(obj, drawings, color)
        end
    end
end

-- üî• B·∫Øt ƒë·∫ßu ESP Clone
function startESPClone()
    if espConnectionClone then return end

    local COLOR = Color3.fromRGB(0, 255, 0) -- xanh l√°
    scanWorkspaceForAllowed(allowedModelsClone, drawingsClone, COLOR)

    espConnectionClone = RunService.RenderStepped:Connect(function()
        for model, data in pairs(drawingsClone) do
            -- Lu√¥n t·ª± h·ªìi ph·ª•c n·∫øu m·∫•t
            createOrRepairESP(model, drawingsClone, COLOR)
            data = drawingsClone[model]

            if model.Parent and model:FindFirstChild("HumanoidRootPart") then
                local hrp = model.HumanoidRootPart
                local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
                local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

                if data.text then
                    data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
                    data.text.Position = Vector2.new(pos.X, pos.Y)
                    data.text.Visible = onScreen
                end

                if data.highlight then
                    data.highlight.Enabled = true
                end
            else
                if data.text then data.text.Visible = false end
                if data.highlight then data.highlight.Enabled = false end
            end
        end
    end)

    addedConnClone = workspace.DescendantAdded:Connect(function(obj)
        -- B·∫Øt c·∫£ khi add v√†o s√¢u trong model
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsClone[model.Name] then
            createOrRepairESP(model, drawingsClone, COLOR)
        end
    end)

    removedConnClone = workspace.DescendantRemoving:Connect(function(obj)
        -- N·∫øu model ho·∫∑c ancestor c·ªßa n√≥ n·∫±m trong b·∫£ng, xo√° ESP
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsClone[model] then
            removeESP(model, drawingsClone)
        end
    end)
end

-- üõë D·ª´ng ESP Clone
function stopESPClone()
    if espConnectionClone then espConnectionClone:Disconnect() end
    if addedConnClone then addedConnClone:Disconnect() end
    if removedConnClone then removedConnClone:Disconnect() end
    for _, data in pairs(drawingsClone) do
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    table.clear(drawingsClone)
    espConnectionClone, addedConnClone, removedConnClone = nil, nil, nil
end

-- üìå Toggle ESP Clone
Tabs.Visual:AddToggle("ESPCloneToggle", {
    Title = "ESP Clone",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then
        startESPClone()
    else
        stopESPClone()
    end
end)





local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- Danh s√°ch model
local allowedModelsWhite = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true, ["Dusekkar"] = true,
}

local allowedModelsRed = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Quest666"] = true
}

-- Containers
local drawingsWhite, drawingsRed = {}, {}
local conWhiteLoop, conWhiteAdded, conWhiteRemoved
local conRedLoop, conRedAdded, conRedRemoved

-- Utility t·∫°o/repair ESP
local function createOrRepairESP(model, drawings, color)
    if not model then return end

    local data = drawings[model]
    if not data then
        local hrp = model:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        -- Text
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color

        -- Highlight
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model

        drawings[model] = { text = text, highlight = highlight }
        return
    end

    -- Repair n·∫øu m·∫•t
    if not data.text then
        local text = Drawing.new("Text")
        text.Size = 14
        text.Center = true
        text.Outline = true
        text.Visible = false
        text.Color = color
        data.text = text
    end
    if not (data.highlight and data.highlight.Parent) then
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
        local highlight = Instance.new("Highlight")
        highlight.Adornee = model
        highlight.FillColor = color
        highlight.OutlineColor = color
        highlight.FillTransparency = 0.7
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Enabled = true
        highlight.Parent = model
        data.highlight = highlight
    end
end

local function removeESP(model, drawings)
    local data = drawings[model]
    if data then
        pcall(function() if data.text then data.text:Remove() end end)
        pcall(function() if data.highlight then data.highlight:Destroy() end end)
    end
    drawings[model] = nil
end

-- Loop ESP update
local function updateESP(drawings, color)
    for model, data in pairs(drawings) do
        if model.Parent and model:FindFirstChild("HumanoidRootPart") then
            createOrRepairESP(model, drawings, color)
            data = drawings[model]

            local hrp = model.HumanoidRootPart
            local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position + Vector3.new(0, 2.5, 0))
            local dist = (hrp.Position - Camera.CFrame.Position).Magnitude

            if data.text then
                data.text.Text = string.format("%s [%.0fm]", model.Name, dist)
                data.text.Position = Vector2.new(pos.X, pos.Y)
                data.text.Visible = onScreen
            end

            if data.highlight then
                data.highlight.Adornee = model
                data.highlight.Enabled = true
            end
        else
            if data.text then data.text.Visible = false end
            if data.highlight then data.highlight.Enabled = false end
        end
    end
end

-- === White ESP ===
local function startESPWhite()
    if conWhiteLoop then return end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedModelsWhite[obj.Name] then
            createOrRepairESP(obj, drawingsWhite, Color3.fromRGB(255, 255, 255))
        end
    end

    conWhiteLoop = RunService.Heartbeat:Connect(function()
        updateESP(drawingsWhite, Color3.fromRGB(255, 255, 255))
    end)

    conWhiteAdded = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsWhite[model.Name] then
            createOrRepairESP(model, drawingsWhite, Color3.fromRGB(255, 255, 255))
        end
    end)
    conWhiteRemoved = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsWhite[model] then
            removeESP(model, drawingsWhite)
        end
    end)
end

local function stopESPWhite()
    if conWhiteLoop then conWhiteLoop:Disconnect(); conWhiteLoop = nil end
    if conWhiteAdded then conWhiteAdded:Disconnect(); conWhiteAdded = nil end
    if conWhiteRemoved then conWhiteRemoved:Disconnect(); conWhiteRemoved = nil end
    for _, d in pairs(drawingsWhite) do
        pcall(function() if d.text then d.text:Remove() end end)
        pcall(function() if d.highlight then d.highlight:Destroy() end end)
    end
    drawingsWhite = {}
end

-- === Red ESP ===
local function startESPRed()
    if conRedLoop then return end
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and allowedModelsRed[obj.Name] then
            createOrRepairESP(obj, drawingsRed, Color3.fromRGB(255, 0, 0))
        end
    end

    conRedLoop = RunService.Heartbeat:Connect(function()
        updateESP(drawingsRed, Color3.fromRGB(255, 0, 0))
    end)

    conRedAdded = workspace.DescendantAdded:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and allowedModelsRed[model.Name] then
            createOrRepairESP(model, drawingsRed, Color3.fromRGB(255, 0, 0))
        end
    end)
    conRedRemoved = workspace.DescendantRemoving:Connect(function(obj)
        local model = obj:IsA("Model") and obj or obj:FindFirstAncestorOfClass("Model")
        if model and drawingsRed[model] then
            removeESP(model, drawingsRed)
        end
    end)
end

local function stopESPRed()
    if conRedLoop then conRedLoop:Disconnect(); conRedLoop = nil end
    if conRedAdded then conRedAdded:Disconnect(); conRedAdded = nil end
    if conRedRemoved then conRedRemoved:Disconnect(); conRedRemoved = nil end
    for _, d in pairs(drawingsRed) do
        pcall(function() if d.text then d.text:Remove() end end)
        pcall(function() if d.highlight then d.highlight:Destroy() end end)
    end
    drawingsRed = {}
end

-- Toggles
Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Survivors",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPWhite() else stopESPWhite() end
end)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killers",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPRed() else stopESPRed() end
end)




-- === ESP Generator (Highlight) ===
local highlights, progressConns = {}, {}
local espLoop
local espEnabled = false
local genAddedConn, genRemovedConn

-- L·∫•y generators trong map
local function getGenerators()
    local list = {}
    local mapRoot = workspace:FindFirstChild("Map")
    local ingame = mapRoot and mapRoot:FindFirstChild("Ingame")
    local mapFolder = ingame and ingame:FindFirstChild("Map")

    for _, obj in ipairs((mapFolder or ingame or mapRoot or workspace):GetDescendants()) do
        if obj:IsA("Model") and obj.Name == "Generator" then
            if not obj.PrimaryPart then
                local part = obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildWhichIsA("BasePart")
                if part then
                    pcall(function() obj.PrimaryPart = part end)
                end
            end
            table.insert(list, obj)
        end
    end
    return list
end

local function isCompleted(gen)
    local p = gen:FindFirstChild("Progress")
    return p and tonumber(p.Value) and p.Value >= 100
end

local function ensureHighlight(gen)
    if highlights[gen] then
        highlights[gen].Enabled = true
        return
    end
    local h = Instance.new("Highlight")
    h.Adornee = gen
    h.FillColor = Color3.fromRGB(255,255,255)
    h.OutlineColor = Color3.fromRGB(255,255,255)
    h.FillTransparency = 0.5
    h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    h.Parent = gen
    highlights[gen] = h
end

local function cleanupModel(gen)
    if progressConns[gen] then
        progressConns[gen]:Disconnect()
        progressConns[gen] = nil
    end
    if highlights[gen] then
        highlights[gen]:Destroy()
        highlights[gen] = nil
    end
end

local function watchProgress(gen)
    if progressConns[gen] then return end
    local p = gen:FindFirstChild("Progress")
    if not p then return end
    progressConns[gen] = p.Changed:Connect(function()
        if not espEnabled then return end
        if isCompleted(gen) then
            if highlights[gen] then highlights[gen].Enabled = false end
        else
            ensureHighlight(gen)
        end
    end)
end

local function startESPGen()
    if espEnabled then return end
    espEnabled = true

    -- Loop c·∫≠p nh·∫≠t m·ªói 0.5s
    espLoop = task.spawn(function()
        while espEnabled do
            for _, gen in ipairs(getGenerators()) do
                if isCompleted(gen) then
                    if highlights[gen] then highlights[gen].Enabled = false end
                else
                    ensureHighlight(gen)
                end
                watchProgress(gen)
            end
            -- cleanup generator b·ªã xo√°
            for gen,_ in pairs(highlights) do
                if not gen:IsDescendantOf(workspace) then
                    cleanupModel(gen)
                end
            end
            task.wait(0.5)
        end
    end)

    -- K·∫øt n·ªëi spawn/remove
    genAddedConn = workspace.DescendantAdded:Connect(function(obj)
        if obj:IsA("Model") and obj.Name == "Generator" then
            task.defer(function()
                if isCompleted(obj) then
                    if highlights[obj] then highlights[obj].Enabled = false end
                else
                    ensureHighlight(obj)
                end
                watchProgress(obj)
            end)
        end
    end)

    genRemovedConn = workspace.DescendantRemoving:Connect(function(obj)
        if highlights[obj] or progressConns[obj] then
            cleanupModel(obj)
        end
    end)
end

local function stopESPGen()
    espEnabled = false
    if espLoop then espLoop = nil end
    if genAddedConn then genAddedConn:Disconnect(); genAddedConn = nil end
    if genRemovedConn then genRemovedConn:Disconnect(); genRemovedConn = nil end
    for gen,_ in pairs(progressConns) do
        cleanupModel(gen)
    end
end

-- Toggle GUI
Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
}):OnChanged(function(state)
    if state then startESPGen() else stopESPGen() end
end)






do
-- ========= Items ESP (auto re-add n·∫øu m·∫•t) =========
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local itemsDraw = {}  -- [tool] = {text, highlight, part}
local conItemsLoop, conItemsAdded, conItemsRemoved

local function getToolPart(tool)
    return tool:FindFirstChild("Handle") or tool:FindFirstChildWhichIsA("BasePart")
end

local function createItemESP(tool)
    if not tool then return end
    local part = getToolPart(tool)
    if not part then return end

    -- N·∫øu ƒë√£ c√≥ highlight th√¨ ch·ªâ update l·∫°i th√¥i
    if itemsDraw[tool] then
        local data = itemsDraw[tool]
        if data.highlight and data.highlight.Parent then
            data.part = part
            return
        end
    end

    -- Text
    local text = Drawing.new("Text")
    text.Size = 14
    text.Center = true
    text.Outline = true
    text.Visible = false
    text.Color = Color3.fromRGB(255, 215, 0)

    -- Highlight
    local hl = Instance.new("Highlight")
    hl.Name = "ItemESP_Highlight"
    hl.Adornee = part
    hl.FillColor = Color3.fromRGB(255, 215, 0)
    hl.OutlineColor = Color3.fromRGB(255, 215, 0)
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Enabled = true
    hl.Parent = tool

    itemsDraw[tool] = { text = text, highlight = hl, part = part }
end

local function removeItemESP(tool)
    local data = itemsDraw[tool]
    if not data then return end
    pcall(function() if data.text then data.text:Remove() end end)
    pcall(function() if data.highlight then data.highlight:Destroy() end end)
    itemsDraw[tool] = nil
end

local function isInIngameFolder(inst)
    local map = workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    return ingame and inst:IsDescendantOf(ingame)
end

local function scanInitialItems()
    local map = workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    if not ingame then return end
    for _, obj in ipairs(ingame:GetDescendants()) do
        if obj:IsA("Tool") then
            createItemESP(obj)
        end
    end
end

local function startESPItems()
    if conItemsLoop then return end

    scanInitialItems()

    -- Auto update
    conItemsLoop = RunService.Heartbeat:Connect(function()
        for _, tool in ipairs(workspace:GetDescendants()) do
            if tool:IsA("Tool") and isInIngameFolder(tool) then
                -- N·∫øu ch∆∞a c√≥ ho·∫∑c b·ªã m·∫•t highlight => t·∫°o l·∫°i
                if not itemsDraw[tool] or not (itemsDraw[tool].highlight and itemsDraw[tool].highlight.Parent) then
                    createItemESP(tool)
                end
            end
        end

        -- Update text/position
        for tool, data in pairs(itemsDraw) do
            local part = data.part or getToolPart(tool)
            if not (tool.Parent and part and part.Parent) or not isInIngameFolder(tool) then
                if data.text then data.text.Visible = false end
                if tool.Parent == nil then
                    removeItemESP(tool)
                end
            else
                data.part = part
                if data.highlight and data.highlight.Adornee ~= part then
                    data.highlight.Adornee = part
                end
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position + Vector3.new(0, 2, 0))
                local dist = (part.Position - Camera.CFrame.Position).Magnitude
                data.text.Text = string.format("%s [%.0fm]", tool.Name, dist)
                data.text.Position = Vector2.new(pos.X, pos.Y)
                data.text.Visible = onScreen
                if data.highlight then data.highlight.Enabled = true end
            end
        end
    end)

    -- Watch for removal
    conItemsRemoved = workspace.DescendantRemoving:Connect(function(obj)
        if itemsDraw[obj] then
            removeItemESP(obj)
        end
    end)
end

local function stopESPItems()
    if conItemsLoop then conItemsLoop:Disconnect(); conItemsLoop = nil end
    if conItemsRemoved then conItemsRemoved:Disconnect(); conItemsRemoved = nil end
    for tool, _ in pairs(itemsDraw) do
        removeItemESP(tool)
    end
    itemsDraw = {}
end

-- Fluent toggle
Tabs.Visual:AddToggle("ESPItemsToggle", {
    Title = "ESP Items",
    Default = false,
}):OnChanged(function(enabled)
    if enabled then startESPItems() else stopESPItems() end
end)
end




-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

-- ‚úÖ FullBright Settings
local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- s√°ng nh·∫π
    Lighting.Brightness = 4 -- gi·∫£m ƒë·ªô s√°ng t·ª´ 10 ‚Üí 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

-- ‚úÖ Toggle: FullBright
local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

-- ‚úÖ Remove Fog Settings
local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

-- ‚úÖ Toggle: Remove Fog
local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)



local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

local ActiveRemoveEffects = false

-- Danh s√°ch t√™n hi·ªáu ·ª©ng th∆∞·ªùng g·∫∑p
local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh s√°ch class hi·ªáu ·ª©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}

-- H√†m xo√° hi·ªáu ·ª©ng
local function removeEffects()
    -- Xo√° hi·ªáu ·ª©ng trong Lighting
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    -- Xo√° GUI overlay
    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end
end

-- Toggle Fluent
Tabs.Misc:AddToggle("RemoveScreenEffects", {
    Title = "Remove Effects",
    Default = true,
    Callback = function(state)
        ActiveRemoveEffects = state
        if state then
            task.spawn(function()
                while ActiveRemoveEffects do
                    removeEffects()
                    task.wait(0.5)
                end
            end)
        end
    end
})


    Tabs.Misc:AddSection("‚Ü≥ Bypass")

local antiAFKCons = {}

-- Ch·ªâ t·∫°o toggle n·∫øu executor c√≥ getconnections
if getconnections then
    Tabs.Misc:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Default = true
    }):OnChanged(function(state)
        local idleCons = getconnections(game.Players.LocalPlayer.Idled)
        
        if state then
            -- L∆∞u & disable
            for _, c in ipairs(idleCons) do
                antiAFKCons[c] = true
                c:Disable()
            end
            print("[AntiAFK] ƒê√£ b·∫≠t, b·∫°n s·∫Ω kh√¥ng b·ªã kick AFK.")
        else
            -- Enable l·∫°i
            for c,_ in pairs(antiAFKCons) do
                if c and c.Enable then
                    pcall(function() c:Enable() end)
                end
            end
            antiAFKCons = {}
            print("[AntiAFK] ƒê√£ t·∫Øt, Roblox s·∫Ω x·ª≠ l√Ω AFK b√¨nh th∆∞·ªùng.")
        end
    end)
else
    warn("[AntiAFK] Executor kh√¥ng h·ªó tr·ª£ getconnections, toggle b·ªã v√¥ hi·ªáu.")
end





Tabs.Misc:AddToggle("AntiReportScreenshot", {
    Title = "Anti-Ban V2",
    Default = true,
    Callback = function(state)
        if not shared.AntiBanLoop then
            shared.AntiBanLoop = {running = false, hooked = false}
        end
        local loopData = shared.AntiBanLoop

        -- üõ°Ô∏è Function Anti Chat + Screenshot Logger (Code 1)
        local function AntiChatLogger()
            local StarterGui = game:GetService("StarterGui")
            local Players = game:GetService("Players")
            local Player = Players.LocalPlayer
            local PlayerScripts = Player:WaitForChild("PlayerScripts")

            local ChatMain = PlayerScripts:FindFirstChild("ChatMain", true)
            if ChatMain then
                local PostMessage = require(ChatMain).MessagePosted
                if PostMessage then
                    local OldHook
                    OldHook = hookfunction(PostMessage.fire, function(self, Message)
                        if not checkcaller() and self == PostMessage then
                            return -- block chat logger
                        end
                        return OldHook(self, Message)
                    end)
                end
            end
            -- Disable abuse screenshot flags
            if setfflag then
                setfflag("AbuseReportScreenshot", "False")
                setfflag("AbuseReportScreenshotPercentage", "0")
            end
        end

        -- üõ°Ô∏è Function Hook Anti Report (Code 2)
        local function hookOnce()
            if not loopData.hookedFind then
                local oldFind = workspace.FindFirstChild
                if typeof(oldFind) == "function" and hookfunction then
                    hookfunction(oldFind, function(self, ...)
                        local args = {...}
                        if tostring(args[1]):lower():find("screenshot") then
                            return nil
                        end
                        return oldFind(self, unpack(args))
                    end)
                    loopData.hookedFind = true
                end
            end

            if not loopData.hookedRequest then
                local oldRequest = (syn and syn.request) or request or http_request
                if hookfunction and typeof(oldRequest) == "function" then
                    hookfunction(oldRequest, function(req)
                        if req and req.Url and tostring(req.Url):lower():find("abuse") then
                            return {StatusCode = 200, Body = "Blocked"}
                        end
                        return oldRequest(req)
                    end)
                    loopData.hookedRequest = true
                end
            end
        end

        local function setFlagsOff()
            local flags = {
                "AbuseReportScreenshot",
                "AbuseReportScreenshotPercentage",
                "AbuseReportEnabled",
                "ReportAbuseMenu",
                "EnableAbuseReportScreenshot"
            }
            for _, flag in ipairs(flags) do
                if typeof(setfflag) == "function" then
                    pcall(function()
                        setfflag(flag, "False")
                    end)
                end
            end
            if typeof(setfflag) == "function" then
                setfflag("AbuseReportScreenshotPercentage", "0")
            end
        end

        local function setFlagsOn()
            if typeof(setfflag) == "function" then
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end
        end

        -- üü¢ Khi b·∫≠t
        if state then
            hookOnce()
            AntiChatLogger()
            setFlagsOff()
            loopData.running = true
            task.spawn(function()
                while loopData.running do
                    setFlagsOff()
                    task.wait(0.05)
                end
            end)
            print("[Anti-Ban] üõ°Ô∏è Protection ENABLED!")
        else
            -- üî¥ Khi t·∫Øt
            loopData.running = false
            setFlagsOn()
            print("[Anti-Ban] ‚ö†Ô∏è Protection DISABLED.")
        end
    end
})






do
-- üõ°Ô∏è Anti Noclip Script v·ªõi Toggle (Fluent UI Tabs.Misc)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalizationService = game:GetService("LocalizationService")
local StarterGui = game:GetService("StarterGui")

local LocalPlayer = Players.LocalPlayer
local Character, HumanoidRootPart, Humanoid = nil, nil, nil

local AntiNoclipEnabled = false
local stuckTime = 0
local requiredStuckSeconds = 1

-- ch·ªëng reset li√™n ti·∫øp & b·ªè qua ki·ªÉm tra ngay khi spawn
local lastResetAt = 0
local resetCooldown = 1.5 -- gi√¢y
local lastSpawnAt = 0
local spawnGrace = 1 -- gi√¢y

-- ========= Notify helper (Fluent -> fallback SetCore) =========
local function getLanguage()
    local lang = LocalizationService.RobloxLocaleId or "en-us"
    if string.sub(lang,1,2):lower() == "vi" then return "vi" end
    return "en"
end

local function Notify(msg)
    -- th·ª≠ Fluent tr∆∞·ªõc (n·∫øu c√≥)
    local okFluent = false
    pcall(function()
        if Fluent and typeof(Fluent) == "table" and Fluent.Notify then
            Fluent:Notify({
                Title = "üõ°Ô∏è Anti Noclip",
                Content = msg,
                Duration = 6
            })
            okFluent = true
        end
    end)
    if okFluent then return end
    -- fallback SetCore
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = "üõ°Ô∏è Anti Noclip",
            Text = msg,
            Duration = 6
        })
    end)
end

-- ========= Character wiring =========
local function SetupCharacter(char)
    Character = char
    HumanoidRootPart = char:WaitForChild("HumanoidRootPart", 5)
    Humanoid = char:WaitForChild("Humanoid", 5)
    lastSpawnAt = os.clock()
    stuckTime = 0
end

if LocalPlayer.Character then
    SetupCharacter(LocalPlayer.Character)
end
LocalPlayer.CharacterAdded:Connect(SetupCharacter)

-- ========= Ki·ªÉm tra k·∫πt b√™n trong t∆∞·ªùng (kh√¥ng t√≠nh ƒë·ª©ng s√°t) =========
local CoreNames = {"HumanoidRootPart","UpperTorso","LowerTorso","Torso","Head"}

local function PartInsideOther(part, other)
    -- Ki·ªÉm tra v·ªã tr√≠ part c√≥ n·∫±m trong th·ªÉ t√≠ch other (CanCollide) kh√¥ng
    local rel = other.CFrame:PointToObjectSpace(part.Position)
    local half = other.Size * 0.5
    local margin = 0.03 -- tr√°nh bi√™n
    return math.abs(rel.X) < (half.X - margin)
       and math.abs(rel.Y) < (half.Y - margin)
       and math.abs(rel.Z) < (half.Z - margin)
end

local function IsInsideWall()
    if not Character or not HumanoidRootPart then return false end
    for _, name in ipairs(CoreNames) do
        local p = Character:FindFirstChild(name)
        if p and p:IsA("BasePart") then
            -- ch·ªâ coi l√† k·∫πt khi *·ªû B√äN TRONG* v·∫≠t th·ªÉ CanCollide
            local touching = p:GetTouchingParts()
            for _, t in ipairs(touching) do
                if t and t:IsA("BasePart")
                    and t.CanCollide
                    and t.Transparency < 1
                    and not t:IsDescendantOf(Character)
                then
                    if PartInsideOther(p, t) then
                        return true
                    end
                end
            end
        end
    end
    return false
end

-- ========= Loop =========
RunService.Heartbeat:Connect(function(dt)
    if not AntiNoclipEnabled then return end
    if not Character or not HumanoidRootPart or not Humanoid then return end

    -- b·ªè qua ngay sau spawn & trong th·ªùi gian cooldown sau khi reset
    local now = os.clock()
    if now - lastSpawnAt < spawnGrace then return end
    if now - lastResetAt < resetCooldown then return end

    if IsInsideWall() then
        stuckTime += dt
        if stuckTime >= requiredStuckSeconds then
            -- reset 1 l·∫ßn, sau ƒë√≥ c√≥ cooldown ƒë·ªÉ script ti·∫øp t·ª•c ch·∫°y ƒë∆∞·ª£c ·ªü l·∫ßn sau
            lastResetAt = now
            stuckTime = 0

            -- reset nh√¢n v·∫≠t
            if Humanoid and Humanoid.Health > 0 then
                Humanoid.Health = 0
            end

            -- th√¥ng b√°o theo ng√¥n ng·ªØ
            local lang = getLanguage()
            if lang == "vi" then
                Notify("H√£y c·∫©n th·∫≠n n·∫øu kh√¥ng b·∫°n s·∫Ω b·ªã banned!")
            else
                Notify("Be careful or you might get banned!")
            end
        end
    else
        stuckTime = 0
    end
end)

-- =========================
-- üîò Toggle ·ªü Fluent Tabs.Misc
-- =========================
Tabs.Misc:AddToggle("AntiNoclip", {
    Title = "Anti Noclip",
    Default = true,
    Callback = function(Value)
        AntiNoclipEnabled = Value
        -- b√°o nhanh khi b·∫≠t/t·∫Øt (kh√¥ng b·∫Øt bu·ªôc)
        local lang = getLanguage()
        if Value then
            if lang == "vi" then
                Notify("Anti Noclip: B·∫¨T")
            else
                Notify("Anti Noclip: ON")
            end
        else
            if lang == "vi" then
                Notify("Anti Noclip: T·∫ÆT")
            else
                Notify("Anti Noclip: OFF")
            end
        end
    end
})
end




-- === SafeGenTeleport (Anti Killers V4 Fixed) ===
local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local SafeGenRunning = false
local SafeGenThread

-- Danh s√°ch account th·∫≠t d√πng V2
local AllowedPlayers = {
    ["Hu1a0_Hu9"] = true,
    ["hdksakst"] = true
}

-- Danh s√°ch Killers
local DangerousKillers = {
    Slasher = true, ["1x1x1x1"] = true, c00lkidd = true,
    Noli = true, JohnDoe = true, Quest666 = true,
    PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
    ["1x1x1x1Zombie"] = true
}

-- Danh s√°ch Clones (coi nh∆∞ Killers)
local DangerousClones = {
    PizzaDeliveryRig = true, Mafia1 = true, Mafia2 = true,
    ["1x1x1x1Zombie"] = true
}

-- Danh s√°ch Survivors (b·∫°n c√≥ th·ªÉ bi·∫øn th√†nh)
local Survivors = {
    Noob = true, Guest1337 = true, Elliot = true, Shedletsky = true,
    TwoTime = true, ["007n7"] = true, Chance = true,
    Builderman = true, Taph = true, Dusekkar = true
}

-- ‚úÖ Ki·ªÉm tra c√≥ Killer ho·∫∑c Clone g·∫ßn
local function isDangerNear(position, radius)
    local killersFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Killers")
    if killersFolder then
        for _, killer in ipairs(killersFolder:GetChildren()) do
            local hrp = killer:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (hrp.Position - position).Magnitude
                if (DangerousKillers[killer.Name] or DangerousClones[killer.Name]) and dist <= radius then
                    return true
                end
            end
        end
    end
    return false
end

-- ‚úÖ Teleport ƒë·∫øn generator an to√†n
local function teleportToSafeGenerator()
    local character = LP.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end
    local myPos = character.HumanoidRootPart.Position
    local bestGen, bestDistance = nil, 0

    local mapFolder = workspace:FindFirstChild("Map")
        and workspace.Map:FindFirstChild("Ingame")
        and workspace.Map.Ingame:FindFirstChild("Map")
    if not mapFolder then return end

    for _, gen in ipairs(mapFolder:GetChildren()) do
        if gen.Name == "Generator" and gen:FindFirstChild("Progress") then
            local genPos = gen:GetPivot().Position
            local dist = (myPos - genPos).Magnitude

            -- ch·ªâ ch·ªçn generator xa & kh√¥ng c√≥ Killer/Clone g·∫ßn
            if dist > bestDistance and not isDangerNear(genPos, 40) then
                bestDistance = dist
                bestGen = gen
            end
        end
    end

    if bestGen then
        local offset = CFrame.new(0, 5, -3) -- ƒë·ª©ng cao h∆°n 5 studs, l√πi ra sau 3 studs
        local goalCFrame = bestGen:GetPivot() * offset
        character:PivotTo(goalCFrame)
        print("‚úÖ Teleported safely to generator:", bestGen.Name)
    else
        print("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y generator an to√†n!")
    end
end

-- === Toggle GUI ===
Tabs.Misc:AddToggle("SafeGenTeleport", {
    Title = "Anti Killers V4",
    Default = false
}):OnChanged(function(state)
    SafeGenRunning = state
    if state then
        SafeGenThread = task.spawn(function()
            local delayTime = 0.1
            if AllowedPlayers[LP.Name] then
                print("üöÄ V2 Mode enabled for:", LP.Name)
                delayTime = 0.0000001
            else
                print("üê¢ V1 Mode enabled for:", LP.Name)
            end

            while SafeGenRunning do
                local character = LP.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local charName = character.Name

                    -- üö´ N·∫øu b·∫°n l√† Killer ho·∫∑c Clone ‚Üí kh√¥ng teleport
                    if DangerousKillers[charName] or DangerousClones[charName] then
                        -- do nothing

                    -- ‚úÖ N·∫øu b·∫°n l√† Survivor (ho·∫∑c ch√≠nh t√™n account b·∫°n)
                    elseif Survivors[charName] or charName == LP.Name then
                        if isDangerNear(hrp.Position, 50) then
                            teleportToSafeGenerator()
                        end
                    end
                end
                task.wait(delayTime)
            end
        end)
    else
        SafeGenRunning = false
        SafeGenThread = nil
        print("[SafeGenTeleport] ƒê√£ t·∫Øt.")
    end
end)





-- N√∫t Auto Teleport Cao (1 l·∫ßn duy nh·∫•t khi b·∫≠t)
Tabs.Misc:AddToggle("AutoTeleportHigh", {
    Title = "Anti Bug",
    Default = true
})
:OnChanged(function(Value)
    if Value then
        local char = LP.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            -- Teleport l√™n cao th√™m 10 studs
            char:PivotTo(char.HumanoidRootPart.CFrame + Vector3.new(0, 5, 0))
        end
    end
end)




    Tabs.Misc:AddSection("‚Ü≥ Show")

-- FPS + Ping Drawing Setup
local showFPS = true
local showPing = true

local fpsText = Drawing.new("Text")
fpsText.Size = 16
fpsText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 10)
fpsText.Color = Color3.fromRGB(0, 255, 0)
fpsText.Center = false
fpsText.Outline = true
fpsText.Visible = showFPS

local msText = Drawing.new("Text")
msText.Size = 16
msText.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X - 100, 30)
msText.Color = Color3.fromRGB(0, 255, 0)
msText.Center = false
msText.Outline = true
msText.Visible = showPing

local fpsCounter = 0
local fpsLastUpdate = tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - fpsLastUpdate >= 1 then
        -- Update FPS
        if showFPS then
            fpsText.Text = "FPS: " .. tostring(fpsCounter)
            fpsText.Visible = true
        else
            fpsText.Visible = false
        end

        -- Update Ping
        if showPing then
            local pingStat = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            msText.Text = "Ping: " .. ping .. " ms"

            if ping <= 60 then
                msText.Color = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                msText.Color = Color3.fromRGB(255, 165, 0)
            else
                msText.Color = Color3.fromRGB(255, 0, 0)
            end

            msText.Visible = true
        else
            msText.Visible = false
        end

        fpsCounter = 0
        fpsLastUpdate = tick()
    end
end)

-- ‚úÖ Fluent GUI Toggles chu·∫©n
local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsText.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    msText.Visible = val
end)

-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet("https://raw.githubusercontent.com/hdksakst-ship-it/Hutao-Hub-Omega-X/refs/heads/main/Forsaken-v3.txt"))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Select First Tab By Default
Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()


-- üü¢ DRAGGABLE UI BUTTON WITH ENHANCED CLICK AND HOVER ANIMATIONS
local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

-- Create Floating UI
local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling -- Ensures highest rendering priority
DragUI.Parent = CoreGui -- Overrides all other UI elements

-- Create Circular Button (Draggable + Clickable)
local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50) -- Adjust size if needed
Button.Position = UDim2.new(0, 10, 1, -85) -- Initial position
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- Windows 11 Style
Button.BackgroundTransparency = 0.3 -- Semi-transparent
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://90508203972003" -- Replace with your custom image ID
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true -- Allows drag functionality
Button.ZIndex = 1000 -- Ensure it stays on top

-- Make UI Circular
local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0) -- Full circle
UICorner.Parent = Button

-- Tween Info for Animations
local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

-- Function to simulate RightShift key press
local function SimulateKeyPress()
    VirtualInputManager:SendKeyEvent(true, minimizeUI, false, game)
    task.wait(0.1)
    VirtualInputManager:SendKeyEvent(false, minimizeUI, false, game)
end

-- Click Animation & UI Toggle (Only if NOT dragged too much)
local isDragging = false
local dragThreshold = 10 -- Allow small movement without canceling click

Button.MouseButton1Click:Connect(function()
    if isDragging then return end -- Prevent click after large dragging

    -- Enhanced Click Animation
    local tween = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    })
    tween:Play()
    task.wait(0.1)
    local tweenBack = TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    })
    tweenBack:Play()

    -- Simulate RightShift to Toggle UI
    SimulateKeyPress()
end)

-- Hover Animation
Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

-- Dragging Logic for PC & Mobile
local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false -- Reset dragging state
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then -- Only mark as dragged if movement exceeds threshold
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

-- Dragging Support for PC & Mobile (on the same button)
Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)